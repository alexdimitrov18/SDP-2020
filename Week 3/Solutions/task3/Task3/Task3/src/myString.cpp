#include "myString.h"
#include <string.h>
#include <cmath>

///Понеже VS 2019 се оплаква, че може да настъпят неочаквани последствия от strcpy, с тази команда пермахваме гадния warning,
///за да ни се компилира кода. С проверките, които правим преди използването на strcpy, си гарантираме, че нищо няма да се бъгне (дал бог)
#pragma warning(disable : 4996)

/// В конструктура по подразбиране просто си зануляваме променливите в обекта
myString::myString() {
	str = nullptr;
	len = 0;
}

///Задаваме си конструктура в условието
myString::myString(char* _str) {

	///Зануляваме си променливите в обекта
	str = nullptr;
	len = 0;

	///Ако сме му подали указател, който сочи към нещо изпълняваме копирането
	if (_str != nullptr) {
		len = strlen(_str) + 1; ///Дължината на масива ще е размера на подадения символен низ плюс един символ за '\0'
		str = new char[len]; ///Създаваме си нов масив в динамичната памет с нужния размер
		strcpy(str, _str); ///Копираме низа _str с терминаращата нула в str
	}
}

myString::~myString(){
    delete[] str;
}

void myString::setStr(char* _str) {

	///Правим обичайната проверка ако потребиеля е сбъркал
	if (str != nullptr) {
		delete[] str;
	}


	len = strlen(_str) + 1;
	str = new char[len];
	strcpy(str, _str);
}

int myString::cmp(char* _str) {

	if (_str == nullptr || str == nullptr) {
		return 999;
	}

	int diffSize = strlen(str) - strlen(_str);  ///Иползваме разликата от размерите ако проверяваме дали са еднакви
	int overlapLen = fmin(strlen(str), strlen(_str)); /// Записваме си по-късия размер от двата низа


	///Въртиме двата масива докъдето са с общ размер
	for (int i = 0; i < overlapLen; i++) {
		if (str[i] > _str[i]) return 1;
		if (str[i] < _str[i]) return -1;
	}

	///Ако не сме намерили разлика в символите горе и имат ендаква дължина то те са еднакви
	if (diffSize == 0) {
		return 0;
	}


	///Според зависи, кой низ е по-голям избираме логично лексикографската наредба
	if (strlen(str) > strlen(_str)) {
		return -1;
	}
	else {
		return 1;
	}
}

int myString::find(char* _str) {
	if (_str == nullptr || str == nullptr) {
		return -1;
	}

	///Очевидно ако търсения подниз е с по-голям размер от главния низ няма какво да търсим
	if (strlen(str) < strlen(_str)) {
		return -1;
	}

	///Правим цикъл, с който обхождаме главния масив докато не стигнем до най-последната възможна буква, до която можем да търсим нашия подниз
	for (int i = 0; i < strlen(str) - strlen(_str); i++) {
		int counter = 0; ///Съзадаваме си брояч, с който броим до къде сме стигнали с обхождането на поднизовете

		///Докато двата подниза си съвпадата елемент по елемент и не сме излизнали от подниза увеличаваме брояча
		while (_str[counter]!='\0' && str[i+counter] == _str[counter] ) {
			counter++;
		}

		if (counter == strlen(_str)) return i; ///Ако размерите на двата подниза съвпаднат то очевидно те са еднакви, следователно сме намерили първия сещнат подниз
	}

	return -1; ///Ако не е намерен под низ а сме ободили целия главен низ то значи няма съвпадение

}

void myString::deleteSubStr(char* _str) {
	if (_str == nullptr || str == nullptr) {
		return;
	}

	///Отново ако подниза е по-голям от главния няма как да изтрием нещо
	if (strlen(str) < strlen(_str)) {
		return;
	}

	///Създаваме си променливите
	int pos = -1 ///която пази текущата позиция на намериния подниз
	, shift = 0; ///отместване което използваме за да отмесим всички символи с наляво, за да презапишем премахнатия подниз

	///Докато намираме такъв подниз, какъвто е дадения, в главния низ
	/**
		(pos = this->find(_str)) != -1

		this->find(_str) ///Прилагаме функцията find() върху текущия обект, който както знаем се сочи от указателя this

		след това стойността на горния ред записвамев pos и чак след това правим проверката, която определя дали ще се влезне в тялото на if-a
	*/
	while ((pos = this->find(_str)) != -1) {

		///Докато не сме стигнали до краня на главния низ
		while (str[pos + strlen(_str)+shift] != '\0') {
			///Копираме всеки елемент след намерения подниз с толкова елемента наляво, колкото е големината на подниза
			str[pos + shift] = str[pos + strlen(_str)+shift];
			shift++;
		}

		///Слага ме си новата терминираща нула
		str[pos + shift] = '\0';

		///Зануляваме си променливите, които може да ползваме пак
		shift = 0;
		pos = -1;
	}
}

void myString::concatenateBack(char* _str) {

	///Съзадаваме си нов масив с големина достатъчна да побере двата низа(низа в обекта и подадения низ)
	char* temp = new char[strlen(str) + strlen(_str) + 1];
	temp[strlen(str) + strlen(_str)] = '\0'; ///Слагаме си терминаращата нула да не я забравим
	///Копираме си текущия масив
	strcpy(temp, str);
	///Копираме подадения масив с отстояние, така че да се залепи за другия
	strcpy(temp + strlen(str), _str);

	delete[] str; ///трием заделената памет, към която сочи str
	str = temp;   ///Присвояваме новия масив на str
}

///Тук са еквивалентни операциите, както в горната функция, само че първо копираме подадения масив, а после главния
void myString::concatenateFront(char* _str) {
	char* temp = new char[strlen(str) + strlen(_str) + 1];

	temp[strlen(str) + strlen(_str)] = '\0';
	strcpy(temp, _str);
	strcpy(temp + strlen(_str), str);

	delete[] str;
	str = temp;
}
